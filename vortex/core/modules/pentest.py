import aiohttp
from vortex.core.scanner import BaseScanner
from typing import Dict, Any, List

class PentestEngine(BaseScanner):
    async def scan(self, target: str) -> Dict[str, Any]:
        # Ensure target has protocol
        if not target.startswith("http"):
            target = f"http://{target}"
            
        results = {"vulnerabilities": []}
        
        try:
            async with aiohttp.ClientSession() as session:
                # 1. Clickjacking Check
                async with session.get(target, ssl=False, timeout=5) as response:
                    if "X-Frame-Options" not in response.headers and "Content-Security-Policy" not in response.headers:
                        results["vulnerabilities"].append({
                            "type": "Clickjacking",
                            "severity": "Medium",
                            "description": "Missing X-Frame-Options and CSP headers",
                            "evidence": "Headers missing"
                        })
                    
                    # 2. Server Information Leakage
                    if "Server" in response.headers:
                         results["vulnerabilities"].append({
                            "type": "Information Leakage",
                            "severity": "Low",
                            "description": f"Server header exposed: {response.headers['Server']}",
                            "evidence": response.headers['Server']
                        })

                # 3. Simple Payload Verification (Safe)
                # Check for reflected XSS potential (very basic)
                payload = "<script>alert(1)</script>"
                params = {"q": payload}
                async with session.get(target, params=params, ssl=False, timeout=5) as response:
                    text = await response.text()
                    if payload in text:
                         results["vulnerabilities"].append({
                            "type": "Reflected XSS (Potential)",
                            "severity": "High",
                            "description": "Input reflected in response without encoding",
                            "evidence": f"Payload {payload} found in response"
                        })

                # 4. SQL Injection Fuzzing (Safe)
                # We look for database errors in the response
                sqli_payloads = ["'", "\"", "1' OR '1'='1"]
                for sql_payload in sqli_payloads:
                    params = {"id": sql_payload}
                    async with session.get(target, params=params, ssl=False, timeout=5) as response:
                        text = await response.text()
                        if "syntax error" in text.lower() or "mysql" in text.lower() or "postgres" in text.lower():
                             results["vulnerabilities"].append({
                                "type": "SQL Injection (Potential)",
                                "severity": "Critical",
                                "description": "Database error message found in response",
                                "evidence": f"Payload {sql_payload} triggered error"
                            })
                             break # Found one, stop fuzzing to be safe

                # 5. XSS Fuzzing (More payloads)
                xss_payloads = ["<img src=x onerror=alert(1)>", "javascript:alert(1)"]
                for xss_payload in xss_payloads:
                    params = {"search": xss_payload}
                    async with session.get(target, params=params, ssl=False, timeout=5) as response:
                        text = await response.text()
                        if xss_payload in text:
                             results["vulnerabilities"].append({
                                "type": "Reflected XSS",
                                "severity": "High",
                                "description": "Input reflected in response",
                                "evidence": f"Payload {xss_payload} found"
                            })
                             break

        except Exception as e:
            results["error"] = str(e)
            
        # 6. Polyglot Ruby Bridge
        # Execute available ruby scripts and merge results
        try:
            from vortex.core.modules.ruby_bridge import RubyBridge
            bridge = RubyBridge()
            scripts = bridge.list_scripts()
            
            import asyncio
            for script in scripts:
                # Run blocking subprocess in a separate thread to avoid freezing FastAPI
                rb_result = await asyncio.to_thread(bridge.execute_script, script, target)
                
                if rb_result and "vulnerabilities" in rb_result:
                    # Mark source as Ruby
                    for vuln in rb_result["vulnerabilities"]:
                        vuln["source"] = "RubyEngine"
                    results["vulnerabilities"].extend(rb_result["vulnerabilities"])
        except Exception as e:
            # Don't fail the whole scan if ruby bridge fails
            print(f"Ruby Bridge Error: {e}")
            
        return results
